[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Análise de dados com R",
    "section": "",
    "text": "Prefácio\nEste livro está em desenvolvimento.\nR é uma linguagem de programação, criada originalmente por Ross Ihaka e por Robert Gentleman no departamento de Estatística da Universidade de Auckland, Nova Zelândia.\nA R disponibiliza uma ampla variedade de técnicas estatísticas e gráficas o que a torna extremamente poderosa para a análise de dados."
  },
  {
    "objectID": "intro.html#r-e-rstudio",
    "href": "intro.html#r-e-rstudio",
    "title": "1  Introdução",
    "section": "1.1 R e RStudio",
    "text": "1.1 R e RStudio\nComo Ré um software gratuito e de código aberto, você pode simplesmente baixá-lo no seguinte link: https://cran.r-project.org/.\nEmbora R possa ser usado “como está” para muitos propósitos, é fortemente recomendável o de uma IDE chamada RStudio. Existem várias versões do RStudio para diferentes usuários (Desktop, Comercial, Servidor, etc.). A versão gratuita do RStudio Desktop é suficiente para nossos propósitos. O RStudio pode ser baixado no seguinte link: https://www.rstudio.com/."
  },
  {
    "objectID": "intro.html#bibliotecas-pacotes",
    "href": "intro.html#bibliotecas-pacotes",
    "title": "1  Introdução",
    "section": "1.2 Bibliotecas/ pacotes",
    "text": "1.2 Bibliotecas/ pacotes\nR possui várias funções integradas/ nativas, mas uma de suas principais vantagens é que existe um grande número de pacotes disponíveis para instalação e uso. Esses pacotes fornecem funções, recursos e dados adicionais para o ambiente R.\nOs pacotes podem ser instalados de várias maneiras, mas a abordagem mais usual é por meio da função install.packages(). Os pacotes intalados dessa forma são aqueles que estão disponíveis no repositório CRAN.\nPor exemplo, se desejamos instalar o pacote tidyverse:\n\ninstall.packages(\"tidyverse\")\n\nDepois que um pacote é instalado, ele não pode ser usado diretamente na sessão do R. Para fazer isso, temos que “carregar” o pacote na sessão atual, o que geralmente é feito por meio da função library().\n\nlibrary(tidyverse)"
  },
  {
    "objectID": "basics1.html#realizando-cálculos-básicos",
    "href": "basics1.html#realizando-cálculos-básicos",
    "title": "2  Operações básicas e variáveis",
    "section": "2.1 Realizando cálculos básicos",
    "text": "2.1 Realizando cálculos básicos\nEm sua forma mais básica, R pode ser usado como uma calculadora. Operações básicas são executadas de forma muito simples e direta.\n\nAdição, subtração, multiplicação e divisão.\n\n\n\n\nOperação\nR\nResultado\n\n\n\n\n\\(3 + 2\\)\n3 + 2\n5\n\n\n\\(3 - 2\\)\n3 - 2\n1\n\n\n\\(3 \\cdot2\\)\n3 * 2\n6\n\n\n\\(3 / 2\\)\n3 / 2\n1.5\n\n\n\n\nPotenciação\n\n\n\n\nOperação\nR\nResultado\n\n\n\n\n\\(3^2\\)\n3 ^ 2\n9\n\n\n\\(2^{(-3)}\\)\n2 ^ (-3)\n0.125\n\n\n\\(100^{1/2}\\)\n100 ^ (1 / 2)\n10\n\n\n\\(\\sqrt{100}\\)\nsqrt(100)\n10\n\n\n\n\nLogaritmos\n\n\n\n\nOperação\nR\nResultado\n\n\n\n\n\\(\\log(e)\\)\nlog(exp(1))\n1\n\n\n\\(\\log_{10}(1000)\\)\nlog10(1000)\n3\n\n\n\\(\\log_{2}(8)\\)\nlog2(8)\n3\n\n\n\\(\\log_{4}(16)\\)\nlog(16, base = 4)\n2\n\n\n\nUsamos \\(\\ln\\) e \\(\\log\\) de forma intercambiável para representar o logaritmo natural. No R não há ln(), em vez disso, ele usa log() para o logaritmo natural.\n\nAlgumas constantes importantes\n\n\n\n\nOperação\nR\nResultado\n\n\n\n\n\\(\\pi\\)\npi\n3.1415927\n\n\n\\(e\\)\nexp(1)\n2.7182818\n\n\n\n\nTrigonometria\n\nPara aplicar funções trigonométricas no R precisamos converter graus para radianos.\n\n\n\nOperação\nR\nResultado\n\n\n\n\n\\(\\sin(\\pi / 2)\\)\nsin(pi / 2)\n1\n\n\n\\(\\cos(0)\\)\ncos(0)\n1\n\n\n\\(\\tan(\\pi / 4)\\)\ntan(pi / 4)\n1\n\n\n\nNote que o Rpossui várias funções nativas como sqrt(), exp(), log() and sin(). Para consultar a documentação sobre uma função no R, basta colocar um ponto de interrogação (?) seguido pelo nome da função e o RStudio exibirá a documentação. Por exemplo:\n\n?sqrt"
  },
  {
    "objectID": "basics1.html#atribuição-de-variáveis",
    "href": "basics1.html#atribuição-de-variáveis",
    "title": "2  Operações básicas e variáveis",
    "section": "2.2 Atribuição de variáveis",
    "text": "2.2 Atribuição de variáveis\nUm conceito básico em programação é chamado de variável. Um conceito um pouco diferente da forma como lidamos em matemática e estatística.\nNa programação, uma variável nos fornece um “espaço” de armazenamento nomeado.\nOu seja, uma variável nos permite armazenar informações ou dados (um valor ou um objeto), e acessar o conteúdo ao invocar o nome dado a variável.\nVejamos um exemplo.\n\n# Atribuir o valor 25 para x\nx <- 25\n\n# Imprimir o valor da variável x\nprint(x)\n\n[1] 25\n\n\nPodemos realizar operações com as variáveis.\n\n# Atribuir valor para y\ny <- 5\n\n# Imprimir o valor da soma x + y\nx + y\n\n[1] 30\n\n\nA função cat() combina vários itens em uma saída de impressão contínua.\n\ncat(\"x + y é igual a \", x+y)\n\nx + y é igual a  30"
  },
  {
    "objectID": "basics1.html#tipos-de-dados",
    "href": "basics1.html#tipos-de-dados",
    "title": "2  Operações básicas e variáveis",
    "section": "2.3 Tipos de dados",
    "text": "2.3 Tipos de dados\nR lida com vários tipos básicos de dados. Alguns dos tipos mais básicos são:\n\nValores numéricos (numeric)\n\nExemplos: 1, 1.0, 42.5\n\nNúmeros inteiros (integer)\n\nExemplos: 1L, 2L, 42L\n\nNúmeros complexos\n\nExemplo: 4 + 2i\n\nValores lógicos (logical): TRUE ou FALSE.\n\nApesar de não ser recomendado, podemos usar T e F.\nNA (valores ausentes) também são considerados lógicos.\n\nTexto / strings (character)\n\nExemplos: \"a\", \"Estatística\", \"Análise de Dados\"\n\n\nPodemos verificar o tipo de informação no R usando a função class ()\n\n# Exemplo\nx <- 10\nclass(x)\n\n[1] \"numeric\"\n\n\n\n# Exemplo\ny <- \"texto\"\nclass(y)\n\n[1] \"character\""
  },
  {
    "objectID": "basics2.html#vetores",
    "href": "basics2.html#vetores",
    "title": "3  Estruturas de dados",
    "section": "3.1 Vetores",
    "text": "3.1 Vetores\nDe forma breve, um vetor no R é uma forma simples para armazenar dados, podendo conter dados numéricos, caracteres ou dados lógicos.\nVetores são criados com a função de combinação c( ), em que os elementos são listados entre parênteses e separados por vírgula.\n\n# Vetor\nc(2, 4, 6, 8, 10)\n\n[1]  2  4  6  8 10\n\n\nAqui o R simplesmente gerou o vetor. No próximo exemplo o vetor será armazenado na variável x.\n\nx <- c(1, 3, 5, 7, 9)\nx\n\n[1] 1 3 5 7 9\n\n\nVetores em Rdevem conter elementos do mesmo tipo. Ao tentar inserir elementos diferentes em um vetor, eles serão automaticamente convertidos em um único tipo.\n\nc(17, \"Estatística\", TRUE)\n\n[1] \"17\"          \"Estatística\" \"TRUE\"       \n\n\nFreqüentemente, precisamos criar vetores baseados em uma sequência de números. A maneira mais rápida e fácil de fazer isso é com o operador :, que cria uma sequência de números inteiros entre dois valores especificados.\n\n(y = 1:10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNote que neste comando colocamos parênteses em torno da atribuição. Dessa forma o R armazenam o vetor em uma variável chamada y e imprime y no console. É a mesma operação dada a seguir.\n\ny <- c(1:10)\ny\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nUma função nativa bastante interessante para criar uma sequência é a função seq(). Essa função é definida por um valor inicial (start), um valor final (stop) e um incremento (step).\n\nseq(from = 0, to = 100, by = 5)\n\n [1]   0   5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90\n[20]  95 100\n\n\n\n3.1.1 Operações sobre vetores\nUma grande vantagem no uso do R é a aplicação de operações vetorizadas.\nVejamos alguns exemplos e note que as operações são aplicadas sobre cada elemento do vetor x.\n\nx <- c(1:10)\nx + 1\n\n [1]  2  3  4  5  6  7  8  9 10 11\n\n\n\n2 * x\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\n\nx^2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\nlog(x)\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n\n\n\n\n3.1.2 Indexação e subconjuntos\nElementos em um vetor são indexados, com índice iniciado em 1, \\(i = 1, 2, \\cdots\\).\nPodemos imprimir um elemento indicando o vetor e especificando o índice de um elemento entre colchetes [ ].\n\n# Gerando um vetor z com a função seq()\nz <- seq(1, 20, 3)\nz\n\n[1]  1  4  7 10 13 16 19\n\n\nConsultando o valor em um índice\n\nz[1]\n\n[1] 1\n\n\nPodemos definir um subconjunto de um vetor, especificando um intervalo entre colchetes.\n\nz[1:3]\n\n[1] 1 4 7\n\n\n\n\n3.1.3 Operadores\n\n\n\n\n\n\n\n\n\nOperador\nSignificado\nExemplo\nResultado\n\n\n\n\nx < y\nx menor que y\n3 < 42\nTRUE\n\n\nx > y\nx maior que y\n3 > 42\nFALSE\n\n\nx <= y\nx menor ou igual a y\n3 <= 42\nTRUE\n\n\nx >= y\nx maior ou igual a y\n3 >= 42\nFALSE\n\n\nx == y\nxigual a y\n3 == 42\nFALSE\n\n\nx != y\nx diferente de y\n3 != 42\nTRUE\n\n\n!x\nnão x\n!(3 > 42)\nTRUE\n\n\nx | y\nx ou y\n(3 > 42) | TRUE\nTRUE\n\n\nx & y\nx e y\n(3 < 4) & ( 42 > 13)\nTRUE\n\n\n\nEm R, os operadores lógicos são vetorizados.\n\n# Gerando x\nx <- c(1:10)\n# Verificando elementos de x maiores do que 5\nx > 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n# Elementos de x iguais a 3\nx == 3\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n# Elementos de x maiores ou iguais a 3 e menores ou iguais a 5\nx >= 3 & x <= 5\n\n [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\n\n3.1.3.1 Algumas funções\n\nComprimento de um vetor: função length()\n\n\nlength(x)\n\n[1] 10\n\n\n\nSoma de elementos: função sum()\n\n\nsum(x)\n\n[1] 55\n\n\nApesar de não estarmos lidando diretamente com o conteúdo de estatística nesta capítulo, vamos adiantar algumas funções simples permite sumarizar os dados de um vetor.\n\nValor máximo: max()\n\n\nmax(x)\n\n[1] 10\n\n\n\nValor mínimo: min()\n\n\nmin(x)\n\n[1] 1\n\n\n\nMédia: mean()\n\n\nmean(x)\n\n[1] 5.5"
  },
  {
    "objectID": "basics2.html#matrizes",
    "href": "basics2.html#matrizes",
    "title": "3  Estruturas de dados",
    "section": "3.2 Matrizes",
    "text": "3.2 Matrizes\nMatrizes são tabelas retangulares de números, expressões matemáticas ou símbolos, cujo elementos são arranjados em \\(n\\) linhas e \\(p\\) colunas. A matrix \\(M\\) abaixo, por exemplo, organiza cada elemento \\(a_{ij}\\) em \\(n\\) linhas e \\(p\\) colunas.\n\\[\nM = \\begin{bmatrix}\n            x_{11}       & x_{12} & x_{13} & \\dots & x_{1p} \\\\\n            x_{21}       & x_{22} & x_{23} & \\dots & x_{2p} \\\\\n            \\dots \\\\\n            x_{n1}       & x_{n2} & x_{n3} & \\dots & x_{np}\n    \\end{bmatrix}\n\\]\nNo R, uma matriz é uma estrutura de dados homogênea (deve conter mesmo tipo de dados, e.i. numérico, caracteres, lógico) de duas dimensões.\nSua sintaxe básica é realizada por meio da função matrix(), tendo como argumentos os elementos que compõem a matriz.\nmatrix(a, nrow = b, ncol = c)\n\na representa os dados; b o número de linhas; c o número de colunas.\n\n\n# Matriz 2x2 de valores 1\nmatrix(1, nrow = 2, ncol = 2)\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    1    1\n\n\nNo exemplo acima as entradas da matriz foram preenchidas com o mesmo valor 1. Podemos “alimentar” uma matriz com valores em sequências ou vetores.\n\n# Criar uma sequência em x\nx = 1:9\n# Reformatar os valores de x para uma matriz 3X3\nX = matrix(x, nrow = 3, ncol = 3)\nX\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nNote que estamos usando duas variáveis diferentes: x minúsculo armazena um vetor e X maiúsculo armazena uma matriz (seguindo uma convenção usual). Podemos fazer isso porque Rdiferencia maiúsculas de minúsculas.\nPor padrão, a função matrix reordena um vetor em colunas, mas também podemos fazer o ordenamento por linhas. O argumento byrow recebe um valor lógico, sendo FALSE (o padrão), e a matriz é preenchida por colunas. Caso contrário (byrow = TRUE), a matriz é preenchida por linhas.\n\nY = matrix(x, nrow = 3, ncol = 3, byrow = TRUE)\nY\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nNo próximo exemplo vamos definir vetores.\n\n# Definindo 3 vetores\nv1 <- c(1, 5, 10)\nv2 <- c(5, 9, 15)\nv3 <- c(3, 8, 12)\n\nAgora vamos combinar os vetores anteriores\n\nv <- c(v1, v2, v3)\nv\n\n[1]  1  5 10  5  9 15  3  8 12\n\n\nE formar uma matriz com essa combinação.\n\nM <- matrix(v, nrow = 3, byrow = TRUE )\nM\n\n     [,1] [,2] [,3]\n[1,]    1    5   10\n[2,]    5    9   15\n[3,]    3    8   12\n\n\nAssim como os vetores, as matrizes também são indexadas, por linhas e colunas. Como são bidimensionais, precisamos especificar linhas e colunas entre colchetes [] ao criar subconjuntos.\n\n# Elemento da linha 1 e coluna 2\nM[1, 2]\n\n[1] 5\n\n\nTambém podemos obter subconjunto de uma linha ou coluna inteira.\n\n# Linha 1\nM[1, ]\n\n[1]  1  5 10\n\n\n\n# Coluna 3\nM[, 3]\n\n[1] 10 15 12"
  },
  {
    "objectID": "basics2.html#as-funções-cbind-e-rbind",
    "href": "basics2.html#as-funções-cbind-e-rbind",
    "title": "3  Estruturas de dados",
    "section": "3.3 As funções cbind e rbind",
    "text": "3.3 As funções cbind e rbind\n\n3.3.1 A função cbind\nA função cbind permite concatenar vetores e matrizes (e dataframes) por colunas.\n\n# Gerar 3 vetores\nx1 <- c(10, 20, 30)\nx2 <- c(5, 15, 20)\nx3 <- c(20, 40, 60)\n\nX <- cbind(x1, x2, x3)\nX\n\n     x1 x2 x3\n[1,] 10  5 20\n[2,] 20 15 40\n[3,] 30 20 60\n\n\nVamos aplicar essa função em 2 matrizes.\n\nM1 <- matrix(1:4, nrow = 2, ncol = 2)\nM2 <- matrix (0, nrow = 2, ncol = 2)\n\nM <- cbind(M1, M2)\nM\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    0    0\n[2,]    2    4    0    0\n\n\n\n\n3.3.2 A função rbind\nA função rbind permite concatenar vetores e matrizes (e dataframes) por linhas.\n\n# Gerar 3 vetores\np1 <- c(1, 3, 5)\np2 <- c(2, 4, 6)\np3 <- c(3, 6, 9)\n\nP <- rbind(p1, p2, p3)\nP\n\n   [,1] [,2] [,3]\np1    1    3    5\np2    2    4    6\np3    3    6    9\n\n\nVamos aplicar a função rbind nas matrizes M1 e M2 geradas anteriormente.\n\nM <- rbind(M1, M2)\nM\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n[3,]    0    0\n[4,]    0    0\n\n\n\n\n3.3.3 Nomeando linhas e colunas de uma matriz\nPodemos atribuir nomes para as linhas de uma matriz com a função rownames:\n\n# Vamos considerar a última matriz X gerada anteriormente\nX\n\n     x1 x2 x3\n[1,] 10  5 20\n[2,] 20 15 40\n[3,] 30 20 60\n\n\nAplicando a função rownames\n\n# Nomeando linhas e colunas\nlinhas <- c(\"linha 1\", \"linha 2\", \"linha 3\")\nrownames(X) <- linhas\nX\n\n        x1 x2 x3\nlinha 1 10  5 20\nlinha 2 20 15 40\nlinha 3 30 20 60\n\n\nAtribuindo nomes para as colunas com a função colnames:\n\ncolunas <- c(\"coluna 1\", \"coluna 2\", \"coluna 3\")\ncolnames(X) <- colunas\nX\n\n        coluna 1 coluna 2 coluna 3\nlinha 1       10        5       20\nlinha 2       20       15       40\nlinha 3       30       20       60\n\n\nA função dimnames também permite nomear linhas e colunas por meio de uma lista de dimensão 2 com nome de linhas (1ª dimensão) e de colunas (2ª dimensão).\n\n# Gerando uma nova matriz\nv <- c(100, 120, 150, 120, 110, 140)\n\nM <- matrix(v, nrow = 3, byrow = TRUE,\n            dimnames = list(c(\"linha 1\", \"linha 2\", \"linha 3\"), \n                            c(\"coluna A\", \"coluna B\")))\nM\n\n        coluna A coluna B\nlinha 1      100      120\nlinha 2      150      120\nlinha 3      110      140\n\n\n\n3.3.3.1 Algumas funções\n\nSoma nas linhas: função rowSums\n\n\n# Somatório nas linhas\ntotal_linha <- rowSums(M)\ntotal_linha\n\nlinha 1 linha 2 linha 3 \n    220     270     250 \n\n\nSoma nas colunas: função colSums:\n\n# Somatório nas linhas\ntotal_coluna <- colSums(M)\ntotal_coluna\n\ncoluna A coluna B \n     360      380"
  },
  {
    "objectID": "basics2.html#cálculos-com-vetores-e-matrizes",
    "href": "basics2.html#cálculos-com-vetores-e-matrizes",
    "title": "3  Estruturas de dados",
    "section": "3.4 Cálculos com vetores e matrizes",
    "text": "3.4 Cálculos com vetores e matrizes\nConsiderando nosso estudo sobre vetores e matrizes. Vamos revisar algumas operações com matrizes e ver como podemos realizar estas operações com R.\nVamos definir duas matrizes \\(A\\) e \\(B\\):\n\nA <-  matrix(c(2, 0, 0, 1), nrow = 2)\nA\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    0    1\n\n\n\nB <-  matrix(c(1:4), nrow = 2, byrow = TRUE)\nB\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n\n\n3.4.1 Soma\nDada duas matrizes de mesma dimensionalidade, a matriz resultante da soma / substração destas matrizes corresponde à matriz cujos elementos são a soma / subtração dos elementos das matrizes originais.\n\\[\n\\begin{bmatrix}\na & b \\\\\nc & d \\\\\n\\end{bmatrix}\n+\n\\begin{bmatrix}\ne & f \\\\\ng & h \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na+e & b+f \\\\\nc+g & d+h\\\\\n\\end{bmatrix}\n\\]\n\n# Soma de duas matrizes\nA+B\n\n     [,1] [,2]\n[1,]    3    2\n[2,]    3    5\n\n\n\n\n3.4.2 Multiplicação por um escalar\nToda matriz, independente de sua dimensão (ordem), pode ser multiplicada por um escalar \\(k\\), de forma que \\(k ∈ ℝ\\). O escalar é multiplicado por cada elemento da matriz.\n\\[\nk\\cdot \\begin{pmatrix}\n                      a & b\\\\\n                      c & d\n       \\end{pmatrix} =\n       \\begin{pmatrix}\n                     k\\cdot a & k\\cdot b\n                     \\\\ k\\cdot c & k\\cdot d\n       \\end{pmatrix}\n\\]\n\n# Multiplicação por escalar\n2*A\n\n     [,1] [,2]\n[1,]    4    0\n[2,]    0    2\n\n\n\n\n3.4.3 Multiplicação elemento por elemento\n\\[\n\\begin{bmatrix}\na & b \\\\\nc & d \\\\\n\\end{bmatrix}\n*\n\\begin{bmatrix}\ne & f \\\\\ng & h \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na*e & b*f \\\\\nc*g & d*h\\\\\n\\end{bmatrix}\n\\]\nEm R a multiplicação elemento a elemento é realizada por meio do operador * desde que as matrizes tenham as mesmas dimensões.\n\n# Multiplicação elemento a elemento\nA*B\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    0    4\n\n\n\n\n3.4.4 Multiplicação matricial\nA multiplicação entre uma matriz \\((n x m)\\) por uma matriz \\((m x p)\\) resulta em uma matriz de dimensões \\((n x p)\\), cujos elementos são a somatória do produto entre os elementos em linha da matriz que pré-multiplica pelos elementos em coluna da matriz que pós-multiplica.\n\\[\n\\begin{bmatrix}\na & b \\\\\nc & d \\\\\n\\end{bmatrix}\n*\n\\begin{bmatrix}\ne & f \\\\\ng & h \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na*e + b*g& a*f+b*h \\\\\nc*e+d*g & c*f+d*h\\\\\n\\end{bmatrix}\n\\]\nEm R a multiplicação matricial clássica é desenvolvida pelo uso do operador %*%.\n\n# Produto de duas matrizes\nA %*% B\n\n     [,1] [,2]\n[1,]    2    4\n[2,]    3    4\n\n\n\n\n3.4.5 Transposta de uma matriz\n\\[\n\\begin{bmatrix}\na & b \\\\\nc & d \\\\\n\\end{bmatrix}^t\n=\n\\begin{bmatrix}\na & c \\\\\nb & d \\\\\n\\end{bmatrix}\n\\]\nEm R a transposta de uma matriz é determinada pela pela função t().\n\n# Transposta\nt(A)\n\n     [,1] [,2]\n[1,]    2    0\n[2,]    0    1\n\n\n\n\n3.4.6 Determinante de uma matriz\n\\[\ndet\\begin{pmatrix}\na & b\\\\\nc & d\n\\end{pmatrix} = a\\cdot d - c\\cdot b\n\\]\n\\[\ndet(A) = \\sum^n_{j = 1} (-1)^{i+j} . a_{i j} . det(A_{-i -j})\n\\] Em R o determinante de uma matriz é calculado pela função det():\n\n# Determinante\ndet(A)\n\n[1] 2\n\n\n\n\n3.4.7 Inversa de uma matriz\n\\[\nA^{-1} \\cdot A = I\n\\]\nEm R a inversa de uma matriz é estimada pela função solve(), mesma função utilizada para resolução de sistemas de equações em R.\n\n# Inversa\ninv_A = solve(A)\ninv_A\n\n     [,1] [,2]\n[1,]  0.5    0\n[2,]  0.0    1\n\n\nConferindo:\n\n# prova\ninv_A %*%A\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\n\n\n3.4.8 Traço\nO traço de uma matriz é determinado pela soma dos elementos da diagonal da matriz quadrada.\n\\[\ntr\\begin{bmatrix}\na & c\\\\\nb & d\n\\end{bmatrix}=a+d\n\\]\nEm R, a obtenção do traço passa pela extração dos elementos da diagonal da matrix, por meio da função diag(), e a soma destes elementos pela função sum().\n\n# traço\nsum(diag(A))\n\n[1] 3\n\n\n\n\n3.4.9 Autovalores e autovetores\nA decomposição própria (decomposição espectral) consiste em escrever uma matriz \\(A\\) diagonalizável em termos de seus autovetores (\\(v\\)) e autovalores (\\(\\lambda\\)). Na estatística, tal decomposição é base da técnica de componentes principais e análise fatorial.\nDada a matriz \\(A\\), um autovalor de \\(A\\), denotado por \\(\\lambda\\), é definido como um escalar que quando multiplicado por um vetor \\(x\\) não-nulo (com elementos iguais a zero) satisfaz a seguinte expressão:\n\\[ Ax = \\lambda x\\]\nEssa equação pode ser escrita da seguinte forma:\n\\[ (A - \\lambda I)x = 0 \\]\n\\(x = 0\\) (solução trivial) é uma solução desse sistema, mas o autovetor não deve ser um vetor nulo.\nComo \\(A\\) é \\(n \\times n\\), temos \\(n\\) equações e \\(n+1\\) incôgnitas (elementos de \\(x\\) e \\(\\lambda\\). O sistema acima tem solução não trivial apenas se: \\(det (A - \\lambda I)=0\\). Assim passamos a ter \\(n+1\\) equações.\n\nObtemos \\(\\lambda\\) resolvendo \\(det (A - \\lambda I)=0\\). Estes são candidatos a autovalores.\nPara cada autovalor candidato obtemos o autovetor correspondente resolvendo \\((A - \\lambda I)x = 0\\). Autovalores e autovetores são dados pelas soluções não triviais.\n\nEm R a obtenção da matriz de auto-valores e auto-vetores é realizada por meio da função eigen().\n\n# Autovalores e autovetores\neigen(A)\n\neigen() decomposition\n$values\n[1] 2 1\n\n$vectors\n     [,1] [,2]\n[1,]   -1    0\n[2,]    0   -1\n\n\n\n# Autovalores\neval = eigen(A)$values\neval\n\n[1] 2 1\n\n\n\n# Autovetores\nevec = eigen(A)$vectors\nevec\n\n     [,1] [,2]\n[1,]   -1    0\n[2,]    0   -1"
  },
  {
    "objectID": "basics2.html#fatores",
    "href": "basics2.html#fatores",
    "title": "3  Estruturas de dados",
    "section": "3.5 Fatores",
    "text": "3.5 Fatores\nEm R o termo fator se refere a uma classe de objeto que armazenar variáveis categóricas.\nDiferenciar o tipo de variável em um script R é importante para diversas análises estatísticas. Diferentes modelos estatísticos em R possuem formas diferenciadas para lidar com variáveis categóricas ou variaveis contínuas.\nUm bom exemplo de variável categórica refere-se ao estado ocupacional de um indivíduo no mercado de trabalho entre “ocupado” e “desocupado”.\nVamos inicialmente definir um vetor\n\n# Vetor com status de ocupação de 5 pessoas\nocup_vec <- c(\"Ocupado\", \"Desocupado\", \"Ocupado\", \"Desocupado\", \"Ocupado\")\n\nNote que temos um vetor de variáveis de texto.\n\nclass(ocup_vec)\n\n[1] \"character\"\n\n\nVamos agora usar a função factor() para converter esse vetor de caracteres para um fator.\n\n# Converter o vetor em fator\nfactor_ocup_vec <- factor(ocup_vec)\n\nVerificando:\n\nclass(factor_ocup_vec)\n\n[1] \"factor\"\n\n\n\n# Imprimir factor_ocup_vec\nfactor_ocup_vec\n\n[1] Ocupado    Desocupado Ocupado    Desocupado Ocupado   \nLevels: Desocupado Ocupado\n\n\n\n3.5.1 Variáveis categóricas nominais e ordinais\nExistem dois tipos de variáveis categóricas: variáveis categóricas nominais e ordinais.\nEm uma variável categórica nominal não temos um ordenamento implícito; como é o caso de “homens” e “mulheres”. Em contraste, as variáveis categóricas ordinais possuem uma ordem natural, como “baixo”, “médio” e “alto”.\nQuando estamos lidando com um variável categórica ordinal, o R permite que sejam declarados os “níveis” desta variável. Isso é realizado com a função levels().\n\n# Definir um vetor com variável categórica ordinal\ncateg <- c(\"alto\", \"baixo\", \"alto\", \"baixo\", \"medio\", \"medio\", \"baixo\")\n\n# Converter o vetor para um fator\nfactor_categ <- factor(categ)\n\nfactor_categ\n\n[1] alto  baixo alto  baixo medio medio baixo\nLevels: alto baixo medio\n\n\nNote que sem especificar o níveis, eles são listados em ordem alfabética.\nAgora vamos especificar níveis para o fator.\n\n# Especificar os níveis do fator\nlevels(factor_categ) <- c(\"baixo\", \"medio\", \"alto\")\n\n# Verificando informações do fator\nfactor_categ\n\n[1] baixo medio baixo medio alto  alto  medio\nLevels: baixo medio alto\n\n\nPodemos ter um sumário de informações do fator com a função summary().\n\n# Gerar um sumário para factor_categ\nsummary(factor_categ)\n\nbaixo medio  alto \n    2     3     2 \n\n\n\n\n3.5.2 Fatores ordenados\nPara declarar ao R que uma variável possui um ordenamento natural podemos usar dois argumentos adicionais na função factor(): order e levels.\nO argumento order é um valor lógico, e sendo TRUE estamos indicando que o fator é ordenado. No argumento levels fornecemos os valores do fator na ordem correta.\n\n# Definir um vetor com variável categórica ordinal\nconceito <- c(\"A\", \"B\", \"A\", \"C\", \"B\", \"B\", \"C\")\n\n# Converter o vetor para um fator e definir níveis e ordenamento\nfactor_conceito <- factor(conceito, \n                          order = TRUE, \n                          levels = c(\"C\", \"B\", \"A\"))\nfactor_conceito\n\n[1] A B A C B B C\nLevels: C < B < A\n\n\nPodemos verificar um sumário:\n\n# Gerar um sumário para factor_conceito\nsummary(factor_conceito)\n\nC B A \n2 3 2 \n\n\nE podemos comparar diferentes elementos do fator.\n\nfactor_conceito[1] > factor_conceito[2]\n\n[1] TRUE\n\n\n\nfactor_conceito[2] < factor_conceito[4]\n\n[1] FALSE"
  },
  {
    "objectID": "basics2.html#data-frames",
    "href": "basics2.html#data-frames",
    "title": "3  Estruturas de dados",
    "section": "3.6 Data Frames",
    "text": "3.6 Data Frames\nVimos que as matrizes são objetos bidimensionais constituídos por linhas e colunas. Seus elementos assim como os vetores podem ser de apenas de um tipo, ou seja, matrizes no R podem ser constituídas unicamente por caracteres, números ou valores lógicos.\nAo contrário de uma matriz, um Data Frame não precisa ter o mesmo tipo de dados para cada elemento. Um Data Frame é uma lista de vetores em que cada vetor deve conter o mesmo tipo de dados, mas os diferentes vetores podem armazenar dados de diferentes tipos.\nGeralmente, podemos pensar no Data Frame como uma tabela de dados em que cada linha representa uma unidade observacional e cada coluna representa uma variável.\nVamos iniciar criando vetores para armazenar informações de um conjunto de pessoas.\n\n# Criar vetores com caracteristicas de pessoas\nnome = c(\"Pedro\", \"João\", \"Camila\", \"Lucas\", \"Juliana\", \"Marcos\")\nsexo = c(\"masculino\", \"masculino\", \"feminino\", \"masculino\", \"feminino\", \"masculino\")\nidade = c(22, 21, 18, 20, 23, 19)\naltura = c(1.82, 1.78, 1.69, 1.70, 1.65, 1.68)\npeso = c(79.7, 80.1, 66.5, 75.4, 58, 84.2)\nrenda = c(2.0, 3.0, NA, 2.2, 2.5, 3.5)\n\nA partir da informação armazenada nestes vetores, podemos aplicar a função data.frame para criar o Data Frame, nomeado como df. A função head() exibe as primeiras 6 linhas do Data Frame.\n\n# Criar um data frame a partir dos vetores\ndf <- data.frame(nome, sexo, idade, altura, peso, renda)\n\n# A função head() exibe as 6 primeiras linhas do Data Frame\nhead(df)\n\n     nome      sexo idade altura peso renda\n1   Pedro masculino    22   1.82 79.7   2.0\n2    João masculino    21   1.78 80.1   3.0\n3  Camila  feminino    18   1.69 66.5    NA\n4   Lucas masculino    20   1.70 75.4   2.2\n5 Juliana  feminino    23   1.65 58.0   2.5\n6  Marcos masculino    19   1.68 84.2   3.5\n\n\nA função str() exibe informações sobre a estrutura do Data Frame.\n\nstr(df)\n\n'data.frame':   6 obs. of  6 variables:\n $ nome  : chr  \"Pedro\" \"João\" \"Camila\" \"Lucas\" ...\n $ sexo  : chr  \"masculino\" \"masculino\" \"feminino\" \"masculino\" ...\n $ idade : num  22 21 18 20 23 19\n $ altura: num  1.82 1.78 1.69 1.7 1.65 1.68\n $ peso  : num  79.7 80.1 66.5 75.4 58 84.2\n $ renda : num  2 3 NA 2.2 2.5 3.5\n\n\nAlgumas outras funções fornecem informações pontuais sobre o Data Frame como as funções: - ncol() - número de colunas, - nrow() - número de linhas, - dim() - dimensão (nº de linhas e colunas) - colnames() - nome das colunas.\n\n# Número de colunas/ variáveis\nncol(df)\n\n[1] 6\n\n\n\n# Número de linhas/ observações\nnrow(df)\n\n[1] 6\n\n\n\n# Dimensão do Data Frame (n. de linhas x n. de colunas)\ndim(df)\n\n[1] 6 6\n\n\n\n# Nome das colunas / variáveis\ncolnames(df)\n\n[1] \"nome\"   \"sexo\"   \"idade\"  \"altura\" \"peso\"   \"renda\" \n\n\nO tipo de cada coluna individualmente pode ser verificado com a função class\n\nclass(nome)\n\n[1] \"character\"\n\nclass(idade)\n\n[1] \"numeric\"\n\n\n\n3.6.1 Consultando dados no Data Frame\nA manipulação de data frames é similar à manipulação de matrizes. A seleção de elementos segue a mesma lógica. Vamos selecionar a terceira linha da segunda coluna do nosso data frame df.\n\n# Consultar informação da 3ª linha e 1º coluna\ndf[3, 1]\n\n[1] \"Camila\"\n\n\nSelecionar variáveis em um data frame, e no presente caso imprimir as informações, é bastante simples usando o comando: df$x. Veja que usamos o cifrão $ entre o nome do data frame df e a variável que desejamos selecionar x.\n\n# Ver informações da variável sexo\ndf$sexo\n\n[1] \"masculino\" \"masculino\" \"feminino\"  \"masculino\" \"feminino\"  \"masculino\"\n\n\nVimos anteriormente a função head() que exibe as seis primeiras linhas do data frame. De forma similar, a função tail() permite visualizar as seis últimas linhas.\n\ntail(df)\n\n     nome      sexo idade altura peso renda\n1   Pedro masculino    22   1.82 79.7   2.0\n2    João masculino    21   1.78 80.1   3.0\n3  Camila  feminino    18   1.69 66.5    NA\n4   Lucas masculino    20   1.70 75.4   2.2\n5 Juliana  feminino    23   1.65 58.0   2.5\n6  Marcos masculino    19   1.68 84.2   3.5\n\n\nQuando queremos selecionar linhas e colunas específicas, o método de indexação é o seguinte: objeto[linhas,colunas]. Este método de indexação permite total flexibilidade e controle.\n\n# Seleciona apenas primeira linha \ndf[1, ]        \n\n   nome      sexo idade altura peso renda\n1 Pedro masculino    22   1.82 79.7     2\n\n\nObservação: espaço vazio dentro do colchetes diz para o R selecionar todas as colunas. O mesmo se aplica se o espaço das linhas for deixado em branco dados[ ,colunas].\n\n# Seleciona as 3 primeiras linhas\ndf[1:3, ]        \n\n    nome      sexo idade altura peso renda\n1  Pedro masculino    22   1.82 79.7     2\n2   João masculino    21   1.78 80.1     3\n3 Camila  feminino    18   1.69 66.5    NA\n\n\n\n# Seleciona a primeira, a segunda e quinta linhas\ndf[c(1,2,5), ]\n\n     nome      sexo idade altura peso renda\n1   Pedro masculino    22   1.82 79.7   2.0\n2    João masculino    21   1.78 80.1   3.0\n5 Juliana  feminino    23   1.65 58.0   2.5\n\n\n\n# Seleciona a sexta coluna (todas as linhas)\ndf[, 6]\n\n[1] 2.0 3.0  NA 2.2 2.5 3.5\n\n\nAgora vamos visualizar o valor de uma linha específica para uma variável selecionada.\n\n# Ver altura na 3ª linha\ndf[3, 4]\n\n[1] 1.69\n\n\nEssa informação também poderia ser consultada ao especificar a coluna, assim:\n\n# Ver altura na 3ª linha\ndf$altura[3]\n\n[1] 1.69\n\n\nPodemos verificar apenas um subconjunto de variáveis (colunas) no Data Frame.\n\n# Vizualizar variáveis selecionadas\ndf[ ,c(\"nome\", \"sexo\", \"renda\")]\n\n     nome      sexo renda\n1   Pedro masculino   2.0\n2    João masculino   3.0\n3  Camila  feminino    NA\n4   Lucas masculino   2.2\n5 Juliana  feminino   2.5\n6  Marcos masculino   3.5\n\n\nPodemos selecionar dados usando condições lógicas.\n\ndf$altura > 1.70\n\n[1]  TRUE  TRUE FALSE FALSE FALSE FALSE\n\n\nMostrando todas as colunas para observações que atendem uma condição.\n\ndf[df$altura > 1.70 , ]\n\n   nome      sexo idade altura peso renda\n1 Pedro masculino    22   1.82 79.7     2\n2  João masculino    21   1.78 80.1     3\n\n\nPodemos combinar condições.\n\ndf[df$altura <= 1.70 & df$sex == \"masculino\"  ,  ]\n\n    nome      sexo idade altura peso renda\n4  Lucas masculino    20   1.70 75.4   2.2\n6 Marcos masculino    19   1.68 84.2   3.5\n\n\nTambém é possível fazer a seleção de informações conforme critérios usando a função subset(). A regra geral desta função é: subset(dados,condição).\n\nsubset(df, idade > 21)\n\n     nome      sexo idade altura peso renda\n1   Pedro masculino    22   1.82 79.7   2.0\n5 Juliana  feminino    23   1.65 58.0   2.5\n\n\n\n\n3.6.2 Adicionando ou excluindo colunas\nPara adicionar uma coluna é utilizar a regra: objeto$nova_coluna <- vetor.\n\n# Adicionar ao df um vetor com cidades\ndf$cidades <- c(\"São Paulo\", \"Brasília\", \"Belo Horizonte\", \"Recife\", \"Curitiba\", \"São Paulo\")\nhead(df)\n\n     nome      sexo idade altura peso renda        cidades\n1   Pedro masculino    22   1.82 79.7   2.0      São Paulo\n2    João masculino    21   1.78 80.1   3.0       Brasília\n3  Camila  feminino    18   1.69 66.5    NA Belo Horizonte\n4   Lucas masculino    20   1.70 75.4   2.2         Recife\n5 Juliana  feminino    23   1.65 58.0   2.5       Curitiba\n6  Marcos masculino    19   1.68 84.2   3.5      São Paulo\n\n\nSe criarmos uma coluna nova a partir de um valor, R irá repetir esse valor para toda a coluna.\n\n# Adicionar ao df uma coluna com o \"pais = Brasil\"\ndf$pais <- \"Brasil\"\nhead(df)\n\n     nome      sexo idade altura peso renda        cidades   pais\n1   Pedro masculino    22   1.82 79.7   2.0      São Paulo Brasil\n2    João masculino    21   1.78 80.1   3.0       Brasília Brasil\n3  Camila  feminino    18   1.69 66.5    NA Belo Horizonte Brasil\n4   Lucas masculino    20   1.70 75.4   2.2         Recife Brasil\n5 Juliana  feminino    23   1.65 58.0   2.5       Curitiba Brasil\n6  Marcos masculino    19   1.68 84.2   3.5      São Paulo Brasil\n\n\nPara remover uma coluna do data frame podemos usar a regra: objeto$coluna <- NULL:\n\n# Remover coluna \"pais\"\ndf$pais <- NULL\nhead(df)\n\n     nome      sexo idade altura peso renda        cidades\n1   Pedro masculino    22   1.82 79.7   2.0      São Paulo\n2    João masculino    21   1.78 80.1   3.0       Brasília\n3  Camila  feminino    18   1.69 66.5    NA Belo Horizonte\n4   Lucas masculino    20   1.70 75.4   2.2         Recife\n5 Juliana  feminino    23   1.65 58.0   2.5       Curitiba\n6  Marcos masculino    19   1.68 84.2   3.5      São Paulo\n\n\nPodemos substituir valores de uma data frame com a seguinte regra básica objeto[linha,coluna] <- valor.\n\n# Remover coluna \"pais\"\ndf[3, 6] <- 2.0\nhead(df)\n\n     nome      sexo idade altura peso renda        cidades\n1   Pedro masculino    22   1.82 79.7   2.0      São Paulo\n2    João masculino    21   1.78 80.1   3.0       Brasília\n3  Camila  feminino    18   1.69 66.5   2.0 Belo Horizonte\n4   Lucas masculino    20   1.70 75.4   2.2         Recife\n5 Juliana  feminino    23   1.65 58.0   2.5       Curitiba\n6  Marcos masculino    19   1.68 84.2   3.5      São Paulo\n\n\n\n\n3.6.3 Transformar uma variável categórica em fator\n\ndf$sexo <- as.factor(df$sexo)\nstr(df)\n\n'data.frame':   6 obs. of  7 variables:\n $ nome   : chr  \"Pedro\" \"João\" \"Camila\" \"Lucas\" ...\n $ sexo   : Factor w/ 2 levels \"feminino\",\"masculino\": 2 2 1 2 1 2\n $ idade  : num  22 21 18 20 23 19\n $ altura : num  1.82 1.78 1.69 1.7 1.65 1.68\n $ peso   : num  79.7 80.1 66.5 75.4 58 84.2\n $ renda  : num  2 3 2 2.2 2.5 3.5\n $ cidades: chr  \"São Paulo\" \"Brasília\" \"Belo Horizonte\" \"Recife\" ...\n\n\ncidades também pode ser convertido.\n\n\n3.6.4 Sumário estatístico\nA função summary também se aplica para um sumário estatístico das colunas de um Data Frames.\n\nsummary(df)\n\n     nome                  sexo       idade           altura     \n Length:6           feminino :2   Min.   :18.00   Min.   :1.650  \n Class :character   masculino:4   1st Qu.:19.25   1st Qu.:1.683  \n Mode  :character                 Median :20.50   Median :1.695  \n                                  Mean   :20.50   Mean   :1.720  \n                                  3rd Qu.:21.75   3rd Qu.:1.760  \n                                  Max.   :23.00   Max.   :1.820  \n      peso           renda         cidades         \n Min.   :58.00   Min.   :2.000   Length:6          \n 1st Qu.:68.72   1st Qu.:2.050   Class :character  \n Median :77.55   Median :2.350   Mode  :character  \n Mean   :73.98   Mean   :2.533                     \n 3rd Qu.:80.00   3rd Qu.:2.875                     \n Max.   :84.20   Max.   :3.500"
  },
  {
    "objectID": "basics2.html#listas",
    "href": "basics2.html#listas",
    "title": "3  Estruturas de dados",
    "section": "3.7 Listas",
    "text": "3.7 Listas\nEm R uma lista é uma estrutura de dados heterogênea unidimensional.As listas são indexadas como os vetores, com um único valor inteiro, mas cada elemento pode conter um elemento de qualquer tipo: texto, números, vetores, matrizes, data frames, ou mesmo outras listas.\nA lista é uma estrutura de dados versátil podendo conter elementos de diferentes tipos e de tamanhos diferentes. A principal função para as listas é servir como um container para armazenar qualquer número de itens de qualquer tipo.\n\n3.7.1 Criando listas\nListas podem ser criadas com a função list() e a especificação do seu conteúdo é feita com a função c() que vismos desde a criação de vetores.\n\nvec <- c(1,2,3)\nvec_char <- c(\"Estatística\", \"Matemática\", \"Economia\", \"Programação\")\nvec_logic <- c(TRUE, FALSE, TRUE, FALSE)\nlista1 <- list(vec, vec_char, vec_logic)\nlista1\n\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] \"Estatística\" \"Matemática\"  \"Economia\"    \"Programação\"\n\n[[3]]\n[1]  TRUE FALSE  TRUE FALSE\n\n\nNote o resultado acima. Os índices em colchetes duplos [[]] identificam o elemento ou a componente da lista. Os índices em colchete simples [] indicam qual sub-elemento da lista está sendo mostrado. A estrutura de uma lista pode se tornar complicada com o aumento do grau de sub-elementos. Mas essa flexibilidade, faz das listas uma ferramenta de armazenamento de dados para diversos propósitos.\nPodemos visualizar a estrutura de uma lista com a função str().\n\nstr(lista1)\n\nList of 3\n $ : num [1:3] 1 2 3\n $ : chr [1:4] \"Estatística\" \"Matemática\" \"Economia\" \"Programação\"\n $ : logi [1:4] TRUE FALSE TRUE FALSE\n\n\n\n\n3.7.2 Criando uma lista nomeada\n\n# Vetor\nnomes <- c(\"Fortaleza\", \"Recife\", \"Salvador\") \n\n# Matriz\ndistancias <- matrix(c(0, 760, 1180, 760, 0 , 807, 1180, 807, 0), ncol = 3)\n\n# Data Frame\ndados <- data.frame(cidade = c(\"Fortaleza\", \"Recife\", \"Salvador\"),\n                    pop = c(2.7, 1.66, 2.9),\n                    idhm = c(0.754, 0.772, 0.759))\n\n# Criar listas com os elementos acima\nlista_cidades <- list(cidades = nomes, dist = distancias, df = dados)\n\n# Imprimir lista\nlista_cidades\n\n$cidades\n[1] \"Fortaleza\" \"Recife\"    \"Salvador\" \n\n$dist\n     [,1] [,2] [,3]\n[1,]    0  760 1180\n[2,]  760    0  807\n[3,] 1180  807    0\n\n$df\n     cidade  pop  idhm\n1 Fortaleza 2.70 0.754\n2    Recife 1.66 0.772\n3  Salvador 2.90 0.759"
  },
  {
    "objectID": "basics3.html#estruturas-de-controle",
    "href": "basics3.html#estruturas-de-controle",
    "title": "4  Programação Básica - 2",
    "section": "4.1 Estruturas de controle",
    "text": "4.1 Estruturas de controle\nAs estruturas de controle em R permitem controlar o fluxo de execução de comandos em um algoritmo.\nEm computação as estruturas de controle básicas são:\n\nCondicionais: usados para executar uma ou mais instruções se uma condição for atendida.\nIterações/ Loops: o objetivo é repetir um comando determinado número de vezes ou enquanto uma condição é cumprida."
  },
  {
    "objectID": "basics3.html#estruturas-condicionais",
    "href": "basics3.html#estruturas-condicionais",
    "title": "4  Programação Básica - 2",
    "section": "4.2 Estruturas Condicionais",
    "text": "4.2 Estruturas Condicionais\nAs estruturas condicionais são úteis quando queremos analisar um conjunto de condições e decidir por um conjunto de ações a ser executado de acordo com estas condições.\nA aplicação das estruturas condicionais conta com as instruções if , elif e else.\n\n4.2.1 Operadores relacionais\nOperador de igualdade: “==”\nComparações de igualdade são a forma mais simples.\n\nTRUE == TRUE\n\n[1] TRUE\n\n\n\nTRUE == FALSE\n\n[1] FALSE\n\n\nOperador de diferença: “!=”\n\nTRUE != FALSE\n\n[1] TRUE\n\n\nDesigualdades: “>” e “<”\nComparações numéricas:\n\n3 > 5\n\n[1] FALSE\n\n\n\n3 < 5\n\n[1] TRUE\n\n\nNa comparação de strings, R determina a relação com base na ordem alfabética.\n\n\"Cães\" > \"Gatos\"\n\n[1] FALSE\n\n\nNo caso de valores booleanos TRUE é tratado como “1” para aritmética e FALSE é tratado como “0”. Portanto:\n\nTRUE > FALSE\n\n[1] TRUE\n\n\n\nTRUE == 1\n\n[1] TRUE\n\n\n\n4.2.1.1 Comparações com vetores\nComo vimos no capítulo anterior, os operadores relacionais também se aplicam a vetores.\n\nv1 <- c(8, 9, 7, 5, 4, 7, 8, 6)\nv2 <- c(9, 8, 9, 10, 8, 6, 7, 6)\n\n\nv1 > 7\n\n[1]  TRUE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE\n\n\n\nv2 < 7\n\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE\n\n\n\nv1 > v2\n\n[1] FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE\n\n\nMatrizes\n\n# Criar uma matriz com os vetores acima\nM <- matrix(c(v1, v2), nrow = 2, byrow = TRUE)\nM\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]\n[1,]    8    9    7    5    4    7    8    6\n[2,]    9    8    9   10    8    6    7    6\n\n\n\nM <=7\n\n      [,1]  [,2]  [,3]  [,4]  [,5] [,6]  [,7] [,8]\n[1,] FALSE FALSE  TRUE  TRUE  TRUE TRUE FALSE TRUE\n[2,] FALSE FALSE FALSE FALSE FALSE TRUE  TRUE TRUE\n\n\n\n\n4.2.1.2 Operadores lógicos\nE: operador “&”\n\nTRUE & TRUE\n\n[1] TRUE\n\nTRUE & FALSE\n\n[1] FALSE\n\nFALSE & TRUE\n\n[1] FALSE\n\nFALSE & FALSE\n\n[1] FALSE\n\n\n\nx <- 12\nx > 5 & x < 15\n\n[1] TRUE\n\n\nOU: operador “|”\n\nTRUE | TRUE\n\n[1] TRUE\n\nTRUE | FALSE\n\n[1] TRUE\n\nFALSE | TRUE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\n\n\ny <-4\ny < 5 | y > 10\n\n[1] TRUE\n\n\nNÃO: operator “!”\n\n!TRUE\n\n[1] FALSE\n\n!FALSE\n\n[1] TRUE\n\n\n\nis.numeric(5)\n\n[1] TRUE\n\n!is.numeric(5)\n\n[1] FALSE\n\n\nAplicando em vetores\n\nc(TRUE, FALSE, TRUE) & c(TRUE, FALSE, FALSE)\n\n[1]  TRUE FALSE FALSE\n\nc(TRUE, FALSE, TRUE) | c(TRUE, FALSE, FALSE)\n\n[1]  TRUE FALSE  TRUE\n\n\n\nc(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE)\n\nWarning in c(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE): 'length(x) = 3 > 1' in\ncoercion to 'logical(1)'\n\nWarning in c(TRUE, FALSE, TRUE) && c(TRUE, FALSE, FALSE): 'length(x) = 3 > 1' in\ncoercion to 'logical(1)'\n\n\n[1] TRUE\n\nc(TRUE, FALSE, TRUE) || c(TRUE, FALSE, FALSE)\n\nWarning in c(TRUE, FALSE, TRUE) || c(TRUE, FALSE, FALSE): 'length(x) = 3 > 1' in\ncoercion to 'logical(1)'\n\n\n[1] TRUE\n\n\n\n\n\n4.2.2 Comandos condicionais\nUm comando condicional é aquele que permite decidir se um determinado bloco de comandos deve ou não ser executado, a partir do resultado de uma expressão relacional ou lógica.\nIF\nO comando if é usado para testar uma condição e executar uma ação específica se a condição for verdadeira. É uma das estruturas de controle de fluxo básicas em R. A sintaxe geral do comando if no R é:\nif (condição) {\n  # código a ser executado se a condição for verdadeira\n}\nA ‘condição’ é uma expressão que retorna TRUE ou FALSE. Se a condição for verdadeira, o código dentro do bloco será executado, caso contrário, o código será ignorado. É importante observar que o bloco de código dentro do if deve ser escrito entre chaves {}.\nVemos ver alguns exemplos.\n\nExemplo\n\n\n## IF\nx <- 5\n\nif (x > 0) {\n  print(\"x é positivo\")\n}\n\n[1] \"x é positivo\"\n\n\nIF ELSE O comando if pode ser combinado com o comando else para especificar o que acontecerá se a condição não for verdadeira. A sintaxe para o comando if...else é:\nif (condição) {\n  # código a ser executado se a condição for verdadeira\n} else {\n  # código a ser executado se a condição for falsa\n}\n\nExemplo\n\n\nif (x > 0) {\n  print(\"x é positivo\")\n} else {\n  print(\"x é negativo ou zero\")\n}\n\n[1] \"x é positivo\"\n\n\nIF...ELSE IF...ELSE Também podemos especificar uma sequência de testes condicionais usando o comando else if, seguindo o if inicial. Se a primeira condição não for verdadeira, o R passará para a próxima condição e assim por diante, até que uma condição verdadeira seja encontrada ou até que se chegue ao final das condições. Se nenhuma condição for verdadeira, o bloco de código associado ao comando else será executado.\nA sintaxe para o comando if...else if...else é:\nif (condição1) {\n  # código a ser executado se a condição1 for verdadeira\n} else if (condição2) {\n  # código a ser executado se a condição1 for falsa e a condição2 for verdadeira\n} else if (condição3) {\n  # código a ser executado se as condições 1 e 2 forem falsas e a condição3 for verdadeira\n} ...\nelse {\n  # código a ser executado se nenhuma condição for verdadeira\n}\n\nExemplo\n\n\nx <- 3\nif (x > 5) {\n  print(\"x é maior do que 5\")\n} else if (x < 5 & x > 0) {\n  print(\"x é maior que 0 e menor que 5\")\n} else if (x == 0) {\n  print(\"x é igual a 0\")\n} else {\n  print(\"x é menor ou igual a 0\")\n}\n\n[1] \"x é maior que 0 e menor que 5\"\n\n\n\nExemplo\n\n\nx <- 6\nif (x %% 2 == 0){\n    print(\"x é divisível por 2\")\n} else if (x %% 3 == 0){\n    print(\"x é divisível por 3\")\n} else {\n    print(\"x não é divisível por 2 ou 3\")\n}\n\n[1] \"x é divisível por 2\""
  },
  {
    "objectID": "basics3.html#laços-for",
    "href": "basics3.html#laços-for",
    "title": "4  Programação Básica - 2",
    "section": "4.3 Laços FOR",
    "text": "4.3 Laços FOR"
  },
  {
    "objectID": "basics3.html#laços-while",
    "href": "basics3.html#laços-while",
    "title": "4  Programação Básica - 2",
    "section": "4.4 Laços WHILE",
    "text": "4.4 Laços WHILE"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "5  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\n\n1 + 1\n\n[1] 2"
  }
]